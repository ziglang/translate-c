//! A wrapper simplifying common usages of the 'translate-c' tool within build scripts. As well as
//! generating a Zig source file, this wrapper also creates a `Build.Module` rooted at that source
//! file, so that Zig compilations may consume it. Typical `Translator` usage might look something
//! like this:
//! ```
//! const my_exe: *Build.Step.Compile = buildMyExe();
//! const libfoo: *Build.Step.Compile = buildLibfoo();
//! // Our goal is to expose `libfoo` to `my_exe.root_module` as a module named "foo".
//! const tc_dep = b.dependency("translate-c", .{});
//! const libfoo_zig: @import("translate-c").Translator = .init(tc_dep, .{
//!     .name = "libfoo",
//!     .c_source_file = b.addWriteFiles().add("wrapper.h",
//!         \\#define _GNU_SOURCE
//!         \\#include <libfoo.h>
//!         \\
//!     ),
//! });
//! libfoo_zig.linkLibrary(libfoo);
//! my_exe.root_module.addImport("foo", libfoo_zig.mod);
//! // Done! The `linkLibrary` call above has also linked `libfoo` into our binary.
//! ```

/// The Zig source file generated by translate-c. It is allowed to use this path directly. However,
/// for common use cases, consider using the `mod` field instead for convenience.
output_file: Build.LazyPath,
/// A `Build.Module` whose root source file is the Zig source file generated by translate-c. In
/// addition, calls to `Translator.linkLibrary`, `Translator.addObject`, etc, will also call the
/// corresponding function on this `Build.Module`, so using it in a Zig module graph will cause
/// the library in question to be automatically linked.
///
/// It is permitted for the caller to call methods such as `Build.Module.addIncludePath` on this
/// `Build.Module`. However, note that modifying this module does not impact C translation, even
/// if calling a method such as `Build.Module.addIncludePath`.
mod: *Build.Module,

/// The `Build.Step.Run` which is actually running translate-c. This can be modified directly to
/// add custom arguments, but prefer using methods like `linkLibrary` where possible.
run: *Build.Step.Run,

pub const Options = struct {
    /// If this name is given, the output file and the `Build.Step.Run` will be named after it.
    name: ?[]const u8 = null,
    /// The C source file being translated. This is typically either a header file (".h") from the
    /// library in question, or a "stub" source file (perhaps from `Build.Step.WriteFiles`) which
    /// contains only preprocessor directives (e.g. `#define` and `#include`).
    c_source_file: Build.LazyPath,
    target: Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    link_libc: bool = true,
    warnings: enum { ignore, show, @"error" } = .ignore,
};

pub fn init(translate_c_dep: *Build.Dependency, options: Options) Translator {
    return initInner(translate_c_dep.builder, .{
        .exe = translate_c_dep.artifact("translate-c"),
        .aro_resource_dir = translate_c_dep.namedLazyPath("aro_resource_dir"),
        .c_builtins = translate_c_dep.module("c_builtins"),
        .helpers = translate_c_dep.module("helpers"),
    }, options);
}

/// Intended for use only by the translate-c package itself. Outside of this package, prefer `init`.
/// Aside from implementing `init`, this is used for testing the translate-c package, because there
/// is no `Build.Dependency` for us, and also we want to test with different `tc_exe`s.
pub fn initInner(
    b: *Build,
    tc_conf: TranslateCConfig,
    options: Options,
) Translator {
    // Try our best to get a reasonable name; we need one to name the steps and the output file.
    const name = options.name orelse std.fs.path.stem(options.c_source_file.getDisplayName());

    // We start with the basic command: 'path/to/translate-c in.c -o out.zig'
    const run = b.addRunArtifact(tc_conf.exe);
    run.setName(b.fmt("translate-c {s}", .{name}));
    run.addFileArg(options.c_source_file);
    run.addArg("-o");
    const output_file = run.addOutputFileArg(b.fmt("{s}.zig", .{name}));
    // Now we are free to add extra args to `run` as needed.

    const mod = b.createModule(.{
        .root_source_file = output_file,
        .target = options.target,
        .optimize = options.optimize,
        .link_libc = options.link_libc,
    });
    mod.addImport("c_builtins", tc_conf.c_builtins);
    mod.addImport("helpers", tc_conf.helpers);

    if (!options.target.query.isNative()) {
        const triple = options.target.query.zigTriple(b.graph.arena) catch @panic("OOM");
        run.addArg(b.fmt("--target={s}", .{triple}));
    }
    if (options.link_libc) {
        // If we're targeting native Linux, Aro's toolchain can find include directories.
        // Otherwise, we'll have to give it a helping hand.
        if (!options.target.query.isNative() or options.target.result.os.tag != .linux) {
            run.addArg("-nostdlibinc"); // Aro should still check its builtin dir, but we're providing everything else
            const libc = std.zig.LibCDirs.detect(
                b.graph.arena,
                b.graph.zig_lib_directory.path orelse ".",
                options.target.result,
                options.target.query.isNativeAbi(),
                options.link_libc,
                null,
            ) catch |err| std.debug.panic("failed to locate libc: {s}", .{@errorName(err)});
            for (libc.libc_include_dir_list) |include_dir| {
                appendIncludeArg(run, "-isystem", .{ .cwd_relative = include_dir });
            }
            for (libc.libc_framework_dir_list) |framework_dir| {
                appendIncludeArg(run, "-iframework", .{ .cwd_relative = framework_dir });
            }
        }
    } else {
        run.addArg("-nostdinc");
    }

    switch (options.warnings) {
        .ignore => run.addArg("-w"),
        .show => {},
        .@"error" => run.addArg("-Werror"),
    }

    appendIncludeArg(run, "-resource-dir", tc_conf.aro_resource_dir);

    return .{
        .output_file = output_file,
        .mod = mod,
        .run = run,
    };
}
/// Intended for use only by the translate-c package itself.
pub const TranslateCConfig = struct {
    exe: *Build.Step.Compile,
    aro_resource_dir: Build.LazyPath,
    c_builtins: *Build.Module,
    helpers: *Build.Module,
};

/// Links `lib` to `t.mod`, and exposes any headers installed by `lib` to translate-c.
pub fn linkLibrary(t: *const Translator, lib: *Build.Step.Compile) void {
    t.mod.linkLibrary(lib);
    appendIncludeArg(t.run, "-I", lib.getEmittedIncludeTree());
}
/// Adds `obj` to `t.mod`, and exposes any headers installed by `obj` to translate-c.
pub fn addObject(t: *const Translator, obj: *Build.Step.Compile) void {
    t.mod.addObject(obj);
    appendIncludeArg(t.run, "-I", obj.getEmittedIncludeTree());
}
/// Exposes the include path `path` to both translate-c and to `t.mod`.
pub fn addIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addIncludePath(path);
    appendIncludeArg(t.run, "-I", path);
}
/// Exposes the system include path `path` to both translate-c and to `t.mod`.
pub fn addSystemIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addSystemIncludePath(path);
    appendIncludeArg(t.run, "-isystem", path);
}
/// Exposes the "after" include path `path` to both translate-c and to `t.mod`.
pub fn addAfterIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addAfterIncludePath(path);
    appendIncludeArg(t.run, "-idirafter", path);
}
/// Exposes the framework path `path` to both translate-c and to `t.mod`.
pub fn addFrameworkPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addFrameworkPath(path);
    appendIncludeArg(t.run, "-F", path);
}
/// Exposes the system framework path `path` to both translate-c and to `t.mod`.
pub fn addSystemFrameworkPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addSystemFrameworkPath(path);
    appendIncludeArg(t.run, "-iframework", path);
}
/// Exposes the embed path `path` to both translate-c and to `t.mod`.
pub fn addEmbedPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addEmbedPath(path);
    t.run.appendPrefixedFileArg("--embed-dir=", path);
}
/// Exposes the config header generaeted by `ch` to both translate-c and to `t.mod`.
pub fn addConfigHeader(t: *const Translator, ch: *Build.Step.ConfigHeader) void {
    t.mod.addConfigHeader(ch);
    appendIncludeArg(t.run, "-I", ch.getOutputDir());
}

/// Helper function for adding things like `-I /path/to/include/dir` to arg vectors.
fn appendIncludeArg(run: *Build.Step.Run, arg: []const u8, path: Build.LazyPath) void {
    run.addArg(arg);
    run.addDirectoryArg(path);
}

const std = @import("std");
const Build = std.Build;
const Translator = @This();
