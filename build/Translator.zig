//! A wrapper simplifying common usages of the 'translate-c' tool within build scripts. As well as
//! generating a Zig source file, this wrapper also creates a `Build.Module` rooted at that source
//! file, so that Zig compilations may consume it. Typical `Translator` usage might look something
//! like this:
//! ```
//! const my_exe: *Build.Step.Compile = buildMyExe();
//! const libfoo: *Build.Step.Compile = buildLibfoo();
//! // Our goal is to expose `libfoo` to `my_exe.root_module` as a module named "foo".
//! const tc_dep = b.dependency("translate-c", .{});
//! const libfoo_zig: @import("translate-c").Translator = .init(tc_dep, .{
//!     .name = "libfoo",
//!     .c_source_file = b.addWriteFiles().add("wrapper.h",
//!         \\#define _GNU_SOURCE
//!         \\#include <libfoo.h>
//!         \\
//!     ),
//! });
//! libfoo_zig.linkLibrary(libfoo);
//! my_exe.root_module.addImport("foo", libfoo_zig.mod);
//! // Done! The `linkLibrary` call above has also linked `libfoo` into our binary.
//! ```

/// The Zig source file generated by translate-c. It is allowed to use this path directly. However,
/// for common use cases, consider using the `mod` field instead for convenience.
output_file: Build.LazyPath,
/// A `Build.Module` whose root source file is the Zig source file generated by translate-c. In
/// addition, calls to `Translator.linkLibrary`, `Translator.addObject`, etc, will also call the
/// corresponding function on this `Build.Module`, so using it in a Zig module graph will cause
/// the library in question to be automatically linked.
///
/// It is permitted for the caller to call methods such as `Build.Module.addIncludePath` on this
/// `Build.Module`. However, note that modifying this module does not impact C translation, even
/// if calling a method such as `Build.Module.addIncludePath`.
mod: *Build.Module,

/// The `Build.Step.Run` which is actually running translate-c. This can be modified directly to
/// add custom arguments, but prefer using methods like `linkLibrary` where possible.
run: *Build.Step.Run,

pub const Options = struct {
    /// If this name is given, the output file and the `Build.Step.Run` will be named after it.
    name: ?[]const u8 = null,
    /// The C source file being translated. This is typically either a header file (".h") from the
    /// library in question, or a "stub" source file (perhaps from `Build.Step.WriteFiles`) which
    /// contains only preprocessor directives (e.g. `#define` and `#include`).
    c_source_file: Build.LazyPath,
    target: Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
    module_libs: bool = true,
    link_libc: bool = true,
    warnings: enum { ignore, show, @"error" } = .ignore,
};

pub fn init(translate_c_dep: *Build.Dependency, options: Options) Translator {
    return initInner(translate_c_dep.builder, .{
        .exe = translate_c_dep.artifact("translate-c"),
        .aro_resource_dir = translate_c_dep.namedLazyPath("aro_resource_dir"),
        .c_builtins = translate_c_dep.module("c_builtins"),
        .helpers = translate_c_dep.module("helpers"),
    }, options);
}

/// Intended for use only by the translate-c package itself. Outside of this package, prefer `init`.
/// Aside from implementing `init`, this is used for testing the translate-c package, because there
/// is no `Build.Dependency` for us, and also we want to test with different `tc_exe`s.
pub fn initInner(
    b: *Build,
    tc_conf: TranslateCConfig,
    options: Options,
) Translator {
    // Try our best to get a reasonable name; we need one to name the steps and the output file.
    const name = options.name orelse std.fs.path.stem(options.c_source_file.getDisplayName());

    // We start with the basic command: 'path/to/translate-c in.c -o out.zig -MD -MV -MF deps.d'
    const run = b.addRunArtifact(tc_conf.exe);
    run.setName(b.fmt("translate-c {s}", .{name}));
    run.addFileArg(options.c_source_file);
    run.addArg("-o");
    const output_file = run.addOutputFileArg(b.fmt("{s}.zig", .{name}));
    run.addArgs(&.{ "-MD", "-MV", "-MF" });
    _ = run.addDepFileOutputArg("deps.d");
    // Now we are free to add extra args to `run` as needed.

    const mod = b.createModule(.{
        .root_source_file = output_file,
        .target = options.target,
        .optimize = options.optimize,
        .link_libc = options.link_libc,
    });
    mod.addImport("c_builtins", tc_conf.c_builtins);
    mod.addImport("helpers", tc_conf.helpers);

    if (!options.target.query.isNative()) {
        const triple = options.target.query.zigTriple(b.graph.arena) catch @panic("OOM");
        run.addArg(b.fmt("--target={s}", .{triple}));
    }
    if (options.link_libc) {
        // If we're cross-compiling, we need to use Zig's libc directories.
        //
        // Currently calling into Zig's libc detection is also necessary for native targets other
        // than Linux due to deficiencies in Aro's toolchains for non-Linux targets.
        if (!options.target.query.isNative() or options.target.result.os.tag != .linux) {
            run.addArg("-nostdlibinc"); // Aro should still check its builtin dir, but we're providing everything else
            const libc = detectLibCDirs(b, &options.target);
            for (libc.libc_include_dir_list) |include_dir| {
                appendIncludeArg(run, "-isystem", .{ .cwd_relative = include_dir });
            }
            for (libc.libc_framework_dir_list) |framework_dir| {
                appendIncludeArg(run, "-iframework", .{ .cwd_relative = framework_dir });
            }

            // Add Clang builtin includes with `-idirafter` to supplement missing headers
            // like `mm_malloc.h` and `intrin.h` while still preferring Aro's own ones when they exist.
            const clang_intrinsic_include_dir = b.graph.zig_lib_directory.join(b.graph.arena, &.{"include"}) catch @panic("OOM");
            appendIncludeArg(run, "-idirafter", .{ .cwd_relative = clang_intrinsic_include_dir });
        }
    } else {
        run.addArg("-nostdinc");
    }

    if (options.target.query.isNativeOs() and options.target.query.isNativeAbi() and options.link_libc) {
        const paths = std.zig.system.NativePaths.detect(b.graph.arena, &options.target.result) catch |err| {
            std.debug.panic("failed to detect native system paths: {t}", .{err});
        };
        for (paths.warnings.items) |warning| {
            std.log.warn("{s}", .{warning});
        }
        for (paths.include_dirs.items) |include_dir| {
            appendIncludeArg(run, "-isystem", .{ .cwd_relative = include_dir });
        }
        for (paths.framework_dirs.items) |framework_dir| {
            appendIncludeArg(run, "-iframework", .{ .cwd_relative = framework_dir });
        }
        // `paths.rpaths` and `paths.lib_dirs` are intentionally omitted because Aro does not yet support
        // the `-rpath` or `-L` flags. That's fine because Aro isn't doing any codegen, only parsing and
        // semantic analysis, so only needs to know include paths.
    }

    switch (options.warnings) {
        .ignore => run.addArg("-w"),
        .show => {},
        .@"error" => run.addArg("-Werror"),
    }

    appendIncludeArg(run, "-resource-dir", tc_conf.aro_resource_dir);

    if (options.module_libs) {
        run.addArg("-fmodule-libs");
    }

    return .{
        .output_file = output_file,
        .mod = mod,
        .run = run,
    };
}
/// Intended for use only by the translate-c package itself.
pub const TranslateCConfig = struct {
    exe: *Build.Step.Compile,
    aro_resource_dir: Build.LazyPath,
    c_builtins: *Build.Module,
    helpers: *Build.Module,
};

/// Links `lib` to `t.mod`, and exposes any headers installed by `lib` to translate-c.
pub fn linkLibrary(t: *const Translator, lib: *Build.Step.Compile) void {
    t.mod.linkLibrary(lib);
    appendIncludeArg(t.run, "-I", lib.getEmittedIncludeTree());
}
/// Adds `obj` to `t.mod`, and exposes any headers installed by `obj` to translate-c.
pub fn addObject(t: *const Translator, obj: *Build.Step.Compile) void {
    t.mod.addObject(obj);
    appendIncludeArg(t.run, "-I", obj.getEmittedIncludeTree());
}
/// Exposes the include path `path` to both translate-c and to `t.mod`.
pub fn addIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addIncludePath(path);
    appendIncludeArg(t.run, "-I", path);
}
/// Exposes the system include path `path` to both translate-c and to `t.mod`.
pub fn addSystemIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addSystemIncludePath(path);
    appendIncludeArg(t.run, "-isystem", path);
}
/// Exposes the "after" include path `path` to both translate-c and to `t.mod`.
pub fn addAfterIncludePath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addAfterIncludePath(path);
    appendIncludeArg(t.run, "-idirafter", path);
}
/// Exposes the framework path `path` to both translate-c and to `t.mod`.
pub fn addFrameworkPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addFrameworkPath(path);
    appendIncludeArg(t.run, "-F", path);
}
/// Exposes the system framework path `path` to both translate-c and to `t.mod`.
pub fn addSystemFrameworkPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addSystemFrameworkPath(path);
    appendIncludeArg(t.run, "-iframework", path);
}
/// Exposes the embed path `path` to both translate-c and to `t.mod`.
pub fn addEmbedPath(t: *const Translator, path: Build.LazyPath) void {
    t.mod.addEmbedPath(path);
    t.run.addPrefixedDirectoryArg("--embed-dir=", path);
}
/// Exposes the config header generaeted by `ch` to both translate-c and to `t.mod`.
pub fn addConfigHeader(t: *const Translator, ch: *Build.Step.ConfigHeader) void {
    t.mod.addConfigHeader(ch);
    appendIncludeArg(t.run, "-I", ch.getOutputDir());
}

/// If the value is omitted, it is set to 1.
/// `name` and `value` need not live longer than the function call.
pub fn defineCMacro(t: *const Translator, name: []const u8, value: ?[]const u8) void {
    const b = t.mod.owner;
    const macro = b.fmt("-D{s}={s}", .{ name, value orelse "1" });
    t.mod.c_macros.append(b.allocator, macro) catch @panic("OOM");
    t.run.addArg(macro);
}

/// Helper function for adding things like `-I /path/to/include/dir` to arg vectors.
fn appendIncludeArg(run: *Build.Step.Run, arg: []const u8, path: Build.LazyPath) void {
    run.addArg(arg);
    run.addDirectoryArg(path);
}
/// This is just a wrapper for `std.zig.LibCDirs.detect` which caches the per-target results. It is
/// desirable to cache this because `detect` has been observed to be quite slow on macOS for native
/// targets, which leads to the 'configure' phase for this project taking a full minute(!) due to
/// all of the test cases.
///
/// This function assumes `link_libc == true`.
fn detectLibCDirs(b: *Build, target: *const Build.ResolvedTarget) std.zig.LibCDirs {
    // TODO: this is a bad solution. One of three things needs to happen:
    // * The Zig build system gets a better way to cache state like this
    // * Aro or translate-c starts performing this query itself
    // * `LibCDirs` stops being slow, making the caching unnecessary
    const S = struct {
        var lib_c_dirs_cache: std.AutoArrayHashMapUnmanaged(std.Target.Query, std.zig.LibCDirs) = .empty;
    };
    // Assumes that `b.graph.arena` is the same every time this is called. That assumption is valid
    // because `b.graph` is state which is local to the build runner and shared with the whole graph.
    const gop = S.lib_c_dirs_cache.getOrPut(b.graph.arena, target.query) catch @panic("OOM");
    if (!gop.found_existing) {
        gop.value_ptr.* = std.zig.LibCDirs.detect(
            b.graph.arena,
            b.graph.zig_lib_directory.path orelse ".",
            &target.result,
            target.query.isNativeAbi(),
            true,
            null,
        ) catch |err| std.debug.panic("failed to locate libc: {s}", .{@errorName(err)});
    }
    return gop.value_ptr.*;
}

const std = @import("std");
const Build = std.Build;
const Translator = @This();
